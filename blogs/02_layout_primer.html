<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NVIDIA CuTe - A Primer to Understanding Layouts</title>

    <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>

    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-4VP1VKLPKJ"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() { dataLayer.push(arguments); }
      gtag("js", new Date());
      gtag("config", "G-4VP1VKLPKJ");
    </script>
  </head>

  <body class="bg-orange-50 text-gray-900 w-full max-w-3xl mx-auto px-5 md:px-0 pb-20">
    <nav class="flex justify-between items-center py-6 border-b border-gray-300">
      <h1 class="font-serif text-3xl font-bold">Jino Rohit</h1>
      <div class="flex gap-6 text-sm">
        <a href="../index.html" class="hover:text-orange-600 transition">Home</a>
        <a href="./blog.html" class="hover:text-orange-600 transition">Blogs</a>
        <a href="../projects/projects.html" class="hover:text-orange-600 transition">Projects</a>
      </div>
    </nav>

    <header class="mt-12">
      <h1 class="font-serif text-4xl font-bold leading-tight text-gray-950">
        NVIDIA CuTe - A Primer to Understanding Layouts
      </h1>
      <p class="text-sm text-gray-600 mt-4 italic">February 21, 2026 • 10 min read</p>
    </header>

    <article class="mt-10 space-y-8 text-lg text-gray-800 leading-relaxed font-serif">
  
  <section class="space-y-4">
    <p>
      CuTe is a collection of C++ CUDA template abstractions for defining and operating on hierarchically multidimensional layouts of threads and data. 
      CuTe provides Layout and Tensor objects that compactly packages the type, shape, memory space, and layout of data, 
      while performing the complicated indexing for the user. 
    </p>

    <p>
      This blog will walk you through the three main types of layouts that is used in CuTe templates.
    </p>
  </section>

  <section class="space-y-4">
    <h2 class="text-2xl font-serif font-bold text-gray-950">
      What exactly are Layouts?
    </h2>

    <p>
      A layout is a function that maps a logical coordinate to a physical offset in memory. Every layout
      in CuTe is defined by two things: a <strong>shape</strong> and a <strong>stride</strong>.
    </p>

    <p>
      Given a coordinate <strong>c</strong> and a stride <strong>s</strong>, the physical offset is simply
      <strong>c</strong> × <strong>s</strong>. For multiple dimensions, you sum over all dimensions:
    </p>

    <p>
      <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
        <mrow>
          <mi>offset</mi>
          <mo>=</mo>
          <msub><mi>c</mi><mn>0</mn></msub>
          <mo>×</mo>
          <msub><mi>s</mi><mn>0</mn></msub>
          <mo>+</mo>
          <msub><mi>c</mi><mn>1</mn></msub>
          <mo>×</mo>
          <msub><mi>s</mi><mn>1</mn></msub>
          <mo>+</mo>
          <mo>⋯</mo>
        </mrow>
      </math>
    </p>

    <p>That's the whole formula.</p>
   </section>


    <section class="space-y-4">
        <h2 class="text-2xl font-serif font-bold text-gray-950">
            1D Layout
        </h2>

        <p>
            <img src="artifacts/1d-tensor.png" class="mx-auto my-4" />
        </p>

        <p>
          The simplest layout is a flat 1D array. We have 10 elements laid out contiguously in memory.
          To move from one element to the next, we jump by 1. So:
        </p>
        <pre class="text-black-300 text-sm rounded p-4 overflow-x-auto font-mono">
          Layout = (shape, stride) = (10, 1)</pre>
        <p>
          The <strong>shape</strong> tells you how many elements exist, and the <strong>stride</strong> tells you how far apart they are in
          memory.
        </p>
    </section>

    <section class="space-y-4">
        <h2 class="text-2xl font-serif font-bold text-gray-950">
            2D Layout
        </h2>

        <p>
            <img src="artifacts/2d.png" class="mx-auto my-4" />
        </p>

        <p>
            For 2D tensors, you need two dimension - one across the row and another across the column. This two dimensional space is the logical representation 
            of the tensor. But remember in the computer, the physical representation is still a single flat array. So how do we make this mapping? Layouts again dummy :)
        </p>

        <!-- <p>
            But if they need to be squished into a 1d layout, which dimension do we iterate from? This is where row major and column major formats enter.
        </p> -->

        <p>
            For a matrix with shape <code>(M, N)</code> and strides <code>(s_row, s_col)</code>, the formula is:
          </p>
          <pre class="text-black-300 text-sm rounded p-4 overflow-x-auto font-mono">
            offset(row, col) = row × s_row + col × s_col</pre>
          <p>
            The question is: what should <code>s_row</code> and <code>s_col</code> be? This is exactly where
            row-major and column-major formats come in.
          </p>

        <h2 class="text-2xl font-serif font-bold text-gray-950">
            Row major format
        </h2>

        <!-- <p>
            In this format, you store the elements in a row wise fashion. Let's look at an example to better understand this.
        </p> -->

        <p>
          In row major order, elements within the same row are contiguous in memory. You fill in row 0
          entirely, then row 1, and so on. For an <code>M x N</code> matrix, the strides are:
        </p>
        <pre class="text-black-300 text-sm rounded p-4 overflow-x-auto font-mono">
          Layout = (shape, stride) = ((M, N), (N, 1))
          2 x 4 matrix is represented as  ((2, 4), (4, 1))</pre>
        <p>
          Moving across a column (incrementing <em>col</em>) costs 1 hop. Moving down a row
          (incrementing <em>row</em>) costs N hops, because you must skip over the entire row above.
        </p>

        <p>
            <img src="artifacts/row_major.png" class="mx-auto my-4" />
        </p>


        <h2 class="text-2xl font-serif font-bold text-gray-950">
            Column major format
        </h2>

        <!-- <p>
            In this format, you store the elements in columns first fashion.
        </p> -->

        <p>
          In column major order, elements within the same column are contiguous. You fill in column 0
          entirely, then column 1, and so on. For an <code>M x N</code> matrix:
        </p>
        <pre class="text-black-300 text-sm rounded p-4 overflow-x-auto font-mono">
          Layout = (shape, stride) = ((M, N), (1, M))
          2 x 4 matrix is represented as ((2, 4), (1, 2))</pre>
        <p>
          Now moving down a row costs 1 hop (elements in the same column are adjacent), and moving
          across a column costs M hops.
        </p>

        <p>
            <img src="artifacts/column_major.png" class="mx-auto my-4" />
        </p>
    </section>

    <section class="space-y-4">
        <h2 class="text-2xl font-serif font-bold text-gray-950">
            Nested Layouts
        </h2>

        <p>
        So far, shapes and strides have been flat numbers. Nested layouts allow shapes and strides to
        themselves be tuples creating a hierarchy of dimensions.
      </p>
      <p>
        You have a 128xx 128 matrix, and you want to partition it into
        32 x 32 tiles for processing by thread blocks. Each tile is itself laid out row major. A nested
        layout lets you express this tiling directly, instead of computing index arithmetic by hand.
      </p>

        <p>Well, we need an example to understand this more clearly.</p>

        <h2 class="text-2xl font-serif font-bold text-gray-950">
          Layout (4, (2, 4)) : (2, (1, 8))</p>
        </h2> 

        <p>
            <img src="artifacts/nested.png" class="mx-auto my-4" />
        </p>

        <p> What does this even mean?</p>

         <div class="overflow-x-auto my-4">
      <table class="w-full text-sm font-mono border border-gray-300 rounded">
        <thead class="text-black-300">
          <tr>
            <th class="text-left px-4 py-2">Dimension</th>
            <th class="text-left px-4 py-2">Shape</th>
            <th class="text-left px-4 py-2">Stride</th>
            <th class="text-left px-4 py-2">Meaning</th>
          </tr>
        </thead>
        <tbody class="text-gray-800 font-sans">
          <tr class="border-t border-gray-200">
            <td class="px-4 py-2">row</td>
            <td class="px-4 py-2">4</td>
            <td class="px-4 py-2">2</td>
            <td class="px-4 py-2">4 rows, each separated by 2 elements in memory</td>
          </tr>
          <tr class="border-t border-gray-200 bg-orange-50">
            <td class="px-4 py-2">col (fast)</td>
            <td class="px-4 py-2">2</td>
            <td class="px-4 py-2">1</td>
            <td class="px-4 py-2">2 contiguous elements within a sub-tile</td>
          </tr>
          <tr class="border-t border-gray-200">
            <td class="px-4 py-2">col (slow)</td>
            <td class="px-4 py-2">4</td>
            <td class="px-4 py-2">8</td>
            <td class="px-4 py-2">4 sub-tiles, each offset by 8 elements</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p>
      The column dimension is itself a nested layout <code>(2, 4) : (1, 8)</code>. This means: first
      iterate over 2 contiguous elements (stride 1), then step to the next group of 2 by jumping 8
      (stride 8), and do this 4 times.
    </p>
    </section>

    <section class="space-y-4">
      <p>In the next blog, I will walk through the algebra of the layouts, until then, ciao!</p>
    </section>


</article>


    <script>
      lucide.createIcons();
    </script>
  </body>
</html>